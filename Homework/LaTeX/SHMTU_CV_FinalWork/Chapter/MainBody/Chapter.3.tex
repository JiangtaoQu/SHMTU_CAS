\chapter{数据集的获取}
\label{chapter:3}

\section{情况简介}

\section{KMeans聚类算法}

KMeans聚类算法是数据科学领域中最受欢迎和广泛使用的无监督学习算法之一。其核心思想是将数据集中的观测值分组，使得同一组（或称为“聚类”）内的观测值在某种度量下尽可能相似，而不同组之间的观测值则尽可能不同。KMeans算法因其简单性、高效性以及易于解释的结果而在各种应用场景中受到青睐。

\subsection{算法原理与步骤详解}

KMeans聚类算法的工作原理可以概括为以下几个步骤：

\begin{enumerate}
	\item {初始化聚类中心}：首先，算法随机选择数据集中的K个点作为初始的聚类中心。这些点代表了初始的K个聚类。K的值通常由用户根据业务需求或数据分析结果来设定。
	\item {分配数据点到最近聚类}：接下来，算法遍历数据集中的每个点，计算该点到所有聚类中心的距离（通常使用欧几里得距离作为度量标准），然后将该点分配给距离最近的聚类中心。这一步完成后，每个数据点都被分配到了一个聚类中。
	\item {重新计算聚类中心}：在分配完所有数据点后，算法重新计算每个聚类的中心。新的聚类中心是其包含的所有数据点的平均值（在多维空间中，这通常是各维度均值的点）。
	\item {迭代优化}：重复步骤2和3，直到聚类中心不再发生显著变化，或者达到预设的最大迭代次数。每一次迭代都会使聚类中心更接近真实的聚类中心，从而优化聚类结果。
	\item {输出结果}：最终，算法输出K个聚类中心以及每个数据点所属的聚类标签。这些聚类中心和标签可以用于进一步的数据分析或业务决策。
\end{enumerate}

\subsection{距离度量的选择}

在KMeans算法中，距离度量是决定聚类效果的关键因素之一。欧几里得距离是最常用的距离度量方式，它衡量了多维空间中两点之间的直线距离。然而，在某些情况下，其他距离度量方式可能更合适。例如，曼哈顿距离考虑了各维度上的绝对差值之和，适用于某些特定类型的数据（如城市街区距离）。余弦相似性则衡量了两个向量的夹角，更多地关注方向而非大小。选择合适的距离度量方式需要根据数据的性质和业务需求来判断。

\subsection{算法优缺点分析}

KMeans聚类算法的优点在于其简单性、高效性以及易于解释的结果。它能够在短时间内处理大量数据，并输出直观易懂的聚类结果。然而，该算法也存在一些明显的缺点。首先，它需要用户预先设定聚类的数量K，这在很多情况下并不容易确定。其次，KMeans对初始聚类中心的选择非常敏感，不同的初始选择可能导致完全不同的聚类结果。此外，该算法假设每个聚类在所有方向上都是均匀的（即球形聚类），这在现实中可能并不总是成立。最后，KMeans算法在处理噪声和异常值时表现不佳，因为它们可能会对聚类中心产生显著影响。

为了克服这些缺点，研究者们提出了许多改进方法。例如，可以通过多次运行算法并选择最佳结果来减轻对初始聚类中心选择的敏感性；可以使用轮廓系数等评估指标来帮助确定最佳的聚类数量K；还可以考虑使用基于密度的聚类方法（如DBSCAN）来处理非球形聚类或噪声数据。

\subsection{算法应用场景}

KMeans聚类算法在各个领域都有广泛的应用。在市场营销中，它可以帮助企业识别不同的客户群体，从而制定更精准的市场策略。在图像处理中，KMeans可以用于图像压缩和图像分割等任务。在文档聚类中，它可以帮助人们自动地将大量文档按照主题或内容进行分组。此外，KMeans还可以用于异常检测、社交网络分析、生物信息学以及推荐系统等领域。总之，作为一种强大且易于使用的无监督学习算法，KMeans在数据挖掘和机器学习中扮演着重要角色。

\section{KMeans聚类算法程序设计}

\subsection{工作流程}

KMeans聚类算法程序设计的工作流程可以概括为以下几个步骤：

\begin{enumerate}[label=\arabic*.]
	\item \textbf{加载图像}：从指定的目录中加载所有图像文件。这一步通过
	load\_images\_from\_directory函数实现，该函数遍历目录中的文件，筛选出以.jpg或.png为扩展名的图像文件，并使用OpenCV库（`cv2.imread`）读取它们。

	\item \textbf{预处理图像}：将加载的图像展平为一维数组，并组合成一个NumPy数组。这是通过preprocess\_images函数完成的，该函数接受一个图像列表，并将每个图像展平为一个长向量。

	\item \textbf{应用KMeans聚类}：使用apply\_kmeans函数将预处理后的图像数据作为输入，并指定聚类的数量。该函数使用scikit-learn库中的KMeans类来执行KMeans聚类算法，并返回每个图像的聚类标签。

	\item \textbf{复制图像到对应聚类文件夹}：根据聚类标签，将图像复制到输出目录中的相应文件夹。这是通过copy\_images\_to\_clusters函数实现的，该函数首先为每个聚类标签创建一个文件夹（如果不存在），然后根据聚类标签将图像从输入目录复制到相应的聚类文件夹。

	\item \textbf{聚类多个目录中的图像}：cluster\_images函数允许用户指定多个输入目录，并为每个目录中的图像执行上述步骤。该函数遍历输入目录列表，对每个目录中的图像进行聚类，并将结果复制到指定的输出目录。
\end{enumerate}

\subsection{代码解析}

详细代码见"src/cluster/cluster\_func.py"

以下是关键函数的详细解析：

\begin{description}
	\item[load\_images\_from\_directory(directory)]
	此函数遍历给定目录中的所有文件，检查它们是否具有.jpg或.png扩展名，并使用OpenCV的imread函数加载它们。加载的图像被添加到一个列表中并返回。

	\item[preprocess\_images(images)]
	此函数接受一个图像列表，并使用NumPy的flatten方法将每个图像转换为一维数组。然后，它将所有展平的图像组合成一个二维NumPy数组，每行代表一个图像。

	\item[apply\_kmeans(images, num\_clusters)]
	此函数使用scikit-learn的KMeans类来执行聚类。它接受预处理后的图像数据和要创建的聚类数作为输入，并返回每个图像的聚类标签。

	\item[copy\_images\_to\_clusters(input\_directory, output\_directory, labels)]
	此函数根据聚类标签将图像从输入目录复制到输出目录中的相应文件夹。它首先为每个唯一的聚类标签创建一个文件夹（如果尚不存在），然后遍历输入目录中的每个文件，并根据其聚类标签将其复制到相应的文件夹。

	\item[cluster\_images(input\_directories, output\_directory, num\_clusters)]
	此函数是程序的入口点，它接受输入目录列表、输出目录和聚类数作为参数。它遍历每个输入目录，并对其中的图像执行加载、预处理、聚类和复制步骤。这样，用户可以对多个目录中的图像进行聚类，并将结果组织在输出目录中的不同文件夹中。
\end{description}

\section{KMeans聚类算法的应用}

KMeans聚类算法在图像处理中发挥着重要的作用，特别是在数学表达式识别的任务中。本章节将详细介绍如何使用KMeans算法进行数学表达式的分段识别。

相关代码请参考\url{Train/SHMTU_CAS_OCR_RESNET/src/cluster}目录。

\subsection{等号分类的实现}

为了有效地提取出数学表达式中的等号部分，我们采取了裁剪原图的方法。具体而言，我们保留了水平方向上最后的30\%的图片内容，而在垂直方向上则不进行裁剪。这样做的原因是，等号通常在数学表达式的末尾出现，且其高度与整个表达式的高度大致相同。通过这样的裁剪操作，我们能够准确地提取出等号及其周围的区域。

接下来，我们对提取出的图片进行KMeans聚类。由于等号在图像中呈现出特定的视觉特征，因此我们可以将聚类类别设置为两类，以区分等号和非等号区域。通过这一步骤，我们能够得到包含等号的图片集合。

\subsection{计算符的分类策略}

在数学表达式中，常见的计算符包括加号、减号、乘号和除号等。为了对这些计算符进行准确的分类，我们考虑将它们分为以下六类：

\begin{enumerate}
	\item 加号（+）
	\item 减号（-）
	\item 乘号（×）
	\item 汉字“加”
	\item 汉字“减”
	\item 汉字“乘”
\end{enumerate}

针对这六类计算符，我们采用KMeans聚类算法进行分类。由于每类计算符在图像中具有独特的视觉特征，KMeans算法能够有效地将它们区分开来。

\subsection{数字分类的挑战与解决方案}

数字分类是数学表达式识别中的一个重要环节。然而，数字在图像中的表现形式各异，尤其是数字“1”，其宽度较窄，可能导致在按比例裁剪原图时出现错误。具体而言，有时候多余的部分可能会被划分到数字“1”的图片中，而KMeans聚类算法本身并不能很好地处理这种情况。

为了解决这个问题，我们采取了以下策略：在聚类后，我们对每一类进行人工筛选和分类。对于数字类别，我们至少挑选出100张具有代表性的图片，并将其送入卷积神经网络（CNN）中进行进一步的分类。通过CNN的分类，我们能够更准确地识别出每个数字。然后，我们再次进行手动分类，此时的任务变得相对简单，因为错误的分类情况已经大大减少。我们只需要将错误的图片挑选出来，并进行修正即可。

\section{聚类后的后续处理}

经过KMeans聚类算法的处理后，我们得到了各个部分的分类结果。接下来，我们对每一类进行人工筛选和分类，确保分类的准确性。对于每一类，我们至少挑选出100张具有代表性的图片，并将其送入CNN中进行进一步的分类。这样做的目的是为了提高分类的准确性，并确保每个类别都具有足够的样本数量。

在CNN分类之后，我们再次进行手动分类。此时，由于之前的聚类处理已经大大减少了分类错误的情况，因此手动分类的任务变得相对简单。我们只需要将少量分类错误的图片挑选出来，并进行修正即可。通过这样的处理流程，我们能够有效地实现数学表达式的分段识别，为后续的数学表达式解析提供便利。

\section{数据集组成}

数据集在 Hugging Face 公开，仓库地址为 \url{https://huggingface.co/datasets/a645162/shmtu_cas_validate_code}。

下面的结果使用 Python 脚本(Train/SHMTU\_CAS\_OCR\_RESNET/count\_dataset.py)统计。

\subsection{等于符号}

等于符号数据集包含了两种类型的标签：等于号（“=”）和汉字“等于”。
具体组成见表\ref{tab:pic_count_equal_symbol}。

\begin{table}[h]
	\centering
	\begin{tabular}{ccc}
		\toprule
		类别编号 & 符号 & 图片数量 \\
		\midrule
		1 & 等于号（“=”） & 26445张 \\
		2 & 汉字“等于” & 26729张 \\
		\midrule
		总计 & & 53174张 \\
		\bottomrule
	\end{tabular}
	\caption{等于号图片数量统计}
	\label{tab:pic_count_equal_symbol}
\end{table}

\subsection{运算符号}

运算符号数据集包含了三种类型的标签：加号（+）、减号（-）和乘号（×），以及对应的汉字标签。
具体组成见表\ref{tab:pic_count_math_symbols}。

\begin{table}[h]
	\centering
	\begin{tabular}{ccc}
		\toprule
		类别编号 & 符号 & 图片数量 \\
		\midrule
		1 & 加号（+） & 1543张 \\
		2 & 汉字“加” & 1049张 \\
		3 & 减号（-） & 1105张 \\
		4 & 汉字“减” & 1019张 \\
		5 & 乘号（×） & 1038张 \\
		6 & 汉字“乘” & 1199张 \\
		\midrule
		总计 & & 6953张 \\
		\bottomrule
	\end{tabular}
	\caption{数学符号图片数量统计}
	\label{tab:pic_count_math_symbols}
\end{table}

\subsection{数字}

数字数据集包含了从0到9的阿拉伯数字标签。
具体组成见表\ref{tab:pic_count_arabic_numbers}。

\begin{table}[h]
	\centering
	\begin{tabular}{ccc}
		\toprule
		类别编号 & 阿拉伯数字 & 图片数量 \\
		\midrule
		1 & 0 & 3368张 \\
		2 & 1 & 2252张 \\
		3 & 2 & 2808张 \\
		4 & 3 & 2162张 \\
		5 & 4 & 2734张 \\
		6 & 5 & 2801张 \\
		7 & 6 & 3324张 \\
		8 & 7 & 3435张 \\
		9 & 8 & 3367张 \\
		10 & 9 & 3916张 \\
		\midrule
		总计 & & 30167张 \\
		\bottomrule
	\end{tabular}
	\caption{阿拉伯数字图片数量统计}
	\label{tab:pic_count_arabic_numbers}
\end{table}

将数据集与验证集按9:1的比例进行划分，使用ResNet网络进行分类，下面的章节将介绍ResNet网络。
